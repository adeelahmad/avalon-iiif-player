import '../../node_modules/mediaelement/src/css/mediaelementplayer.css'
import QualitySelector from './quality_selector'

/** Class representing a MediaPlayer */
export default class MediaPlayer {
  /**
   * Create a media player instance
   * @param {Object} options - Options object containing manifest and possibly other things?
   */
  constructor (options) {
    this.manifest = options.manifest
    this.target = document.getElementById('iiif-standalone-player-mount')
  }

  /**
   * Gets the first subtitle track from the manifest.
   * It will probably need to more robust in the future
   * @return {string} subtitle - a URI that points to subtitles
   */
  getSubtitles () {
    let subtitlesUri = ''
    this.manifest.content[0].items.forEach((item) => {
      item.body.forEach((body) => {
        if (body.type === 'Text') {
          subtitlesUri = body
        }
      })
    })
    return subtitlesUri
  }

  /**
   * Determine quality choices present in the manifest
   * @param {Object} canvas - A canvas object in the manifest
   * @return {array} An array of quality choices
   */
  getQualityChoices (canvas) {
    let choices = []
    let content = (canvas) ? canvas.content : this.manifest.content

    content[0].items.forEach((item) => {
      item.body.forEach((body) => {
        if (body.type === 'Choice') {
          body.items.forEach((item) => {
            choices.push(item)
          })
        }
      })
    })
    return choices
  }

  /**
   *  Get 'Medium' quality item from the manifest
   * @method MediaPlayer#getVideoUri
   * @return {Object} uri - a item object for the medium quality file
   */
  getVideoUri () {
    let uri = ''
    this.manifest.content[0].items.forEach((item) => {
      item.body.forEach((body) => {
        if (body.type === 'Choice') {
          body.items.forEach((item) => {
            if (item.label === 'Medium') {
              uri = item
            }
          })
        }
      })
    })
    return uri
  }

  getTimeFromUrl (url) {
     /**
     *
     *  this takes a url generated by this software (not a URI from the manifest) and returns an object with start/stop in seconds and the duration in milliseconds
     * @method MediaPlayer#getTimeFromUrl
     *
     * @return {Object}
     */
    let re = new RegExp(/\d*,\d*/)
    let time = url.match(re)[0]
    let splitTime = time.split(',')
    return {
      start: splitTime[0],
      stop: splitTime[1]
    }
  }

  replaceTimeInUrl (url, childStartStopTime) {
   /**
     *
     *  this will replace the /time/345,536/ with a new time when given object like this: { start: 230 , stop : 340 }
     * @method MediaPlayer#replaceTimeInUrl
     *
     * @return {string}
     */
    let startTime = this.getTimeFromUrl(url)
    let ourStart = startTime.start
    let theirStop = childStartStopTime.stop
    let newTimeString = `/time/${ourStart},${theirStop}/`
    let oldTime = (`/time/${startTime.start},${startTime.stop}/`)

    return url.replace(oldTime, newTimeString)
  }

  addUrlsForParents () {
      /**
     *
     *  this will add urls to labels in the structure navigation if they have the class .implicit
     * @method MediaPlayer#addUrlsForParents
     */
    try {
      var parentStopTimes = document.querySelectorAll('.implicit')
      parentStopTimes.forEach((el) => {
        let lastTimeIndex = el.querySelectorAll('.explicit').length - 1
        let childStartStopTime = this.getTimeFromUrl(el.querySelectorAll('.explicit')[lastTimeIndex].querySelector('a').href)
        let newTime = this.replaceTimeInUrl(el.querySelector('.media-structure-uri').href, childStartStopTime)

        let label = el.querySelector('li').textContent
        el.querySelector('li').textContent = ''

        let link = document.createElement('a')
        link.setAttribute('class', 'media-structure-uri')
        link.setAttribute('href', newTime)
        link.text = label
        el.querySelector('li').appendChild(link)
      })
    } catch (e) {
      console.log(e)
    }
  }

  getCanvasByIndex (index) {
    /**
     * Get a canvas object from manifest 'canvases' array
     *
     * @method MediaPlayer#getCanvasIndex
     * @param {string} index - target canvas index
     * @returns {Object} canvasObject or empty object
     */
    if (!index) { return {} }

    // TODO: Eventually we'll want to track current sequence index as well.  For now assume first sequence
    const canvases = this.manifest.sequences[0].canvases
    let canvasObject = {}

    canvases.forEach((canvas) => {
      const canvasIndex = canvas.id.slice(canvas.id.lastIndexOf('/') + 1)
      if (canvasIndex === index) {
        canvasObject = canvas
      }
    })
    return canvasObject
  }

  qualitySelectorMarkup () {
    let qs = new QualitySelector()
    let choices = qs.qualityChoices(this.manifest, '', [])

    return qs.renderChoices(choices)
  }

  renderStructure (manifest, list, canvasId) {
    /**
     * Recurses the manifest structure and creates an html tree
     * @method MediaPlayer#renderStructure
     *
     */
    manifest.map((data, index) => {
      if (data.type === 'Range') {
        canvasId = manifest[index].members[0].id
      }
      if (data.hasOwnProperty('members')) {
        if (this.getMediaFragment(canvasId) !== undefined) {
          list.push(`<ul><li><a class="media-structure-uri" data-media-fragment="${canvasId}">${data.label}</a></li>`)
          this.renderStructure(data.members, list, canvasId)
        } else {
          list.push(`<ul><li>${data.label}</li>`)
          this.renderStructure(data.members, list, canvasId)
        }
      }
    })
    list.push('</ul>')
    return list.join('')
  }

  getCanvases (options) {
    let canvases = []
    let sequences = options.manifest.sequences
    if (sequences && sequences.length > 0) {
      // Default use the first sequence to grab canvases
      canvases = sequences[0].canvases || []
    }
    return canvases
  }
}
